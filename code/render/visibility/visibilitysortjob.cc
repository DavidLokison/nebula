//------------------------------------------------------------------------------
//  visibilitysortjob.cc
//  (C) 2018-2020 Individual contributors, see AUTHORS file
//------------------------------------------------------------------------------
#include "render/stdneb.h"
#include "jobs/jobs.h"
#include "visibilitycontext.h"
#include "models/modelcontext.h"
#include "models/nodes/shaderstatenode.h"
#include "profiling/profiling.h"
namespace Visibility
{

//------------------------------------------------------------------------------
/**
*/
void
VisibilitySortJob(const Jobs::JobFuncContext& ctx)
{
    N_SCOPE(VisibilitySortJob, Visibility);
    Memory::ArenaAllocator<1024>* packetAllocator = (Memory::ArenaAllocator<1024>*)ctx.uniforms[0];
    packetAllocator->Release();

    for (ptrdiff sliceIdx = 0; sliceIdx < ctx.numSlices; sliceIdx++)
    { 
        Math::ClipStatus::Type* results = (Math::ClipStatus::Type*)N_JOB_INPUT(ctx, sliceIdx, 0);
        Models::ModelNode::Instance** const nodes = (Models::ModelNode::Instance**)N_JOB_INPUT(ctx, sliceIdx, 1);
        ObserverContext::VisibilityDrawList* drawList = (ObserverContext::VisibilityDrawList*)N_JOB_OUTPUT(ctx, sliceIdx, 0);

        // calculate amount of models
        uint32 numNodeInstances = ctx.inputSizes[0] / sizeof(Math::ClipStatus::Type);

        n_assert(numNodeInstances < 0xFFFFFFFF)
        
        Util::Array<uint64> indexBuffer;
        for (uint32 i = 0; i < numNodeInstances; i++)
            indexBuffer.Append(i);

        // loop over each node and give them the appropriate weight
        uint32 i = 0;
        while (i < indexBuffer.Size())
        {
            n_assert(indexBuffer[i] < 0x00000000FFFFFFFF);
            uint64 index = indexBuffer[i] & 0x00000000FFFFFFFF;
            Models::ModelNode::Instance* const inst = nodes[index];
            Models::NodeBits bits = inst->node->GetBits();

            // only treat renderable nodes
            if ((bits & Models::HasStateBit) == Models::HasStateBit)
            {
                if (results[index] == Math::ClipStatus::Outside)
                {
                    indexBuffer.EraseIndexSwap(i);
                    continue;
                }

                Models::ShaderStateNode::Instance* const shdNodeInst = reinterpret_cast<Models::ShaderStateNode::Instance*>(inst);
                if (!shdNodeInst->active)
                {
                    indexBuffer.EraseIndexSwap(i);
                    continue;
                }

                Models::ShaderStateNode* const shdNode = reinterpret_cast<Models::ShaderStateNode*>(inst->node);
                n_assert(bits == shdNode->GetBits());

                // note: this assumes the materialType HashCode returns a unique id for each materialType that is generated by counting up from 0.
                //       if we hit this asserts, we might have too many materials or we've changed the way that we assign unique ids to the different materials.
                //       this means we need to rewrite how we sort the indexbuffer, maybe by just storing 3 values, and sorting based on that.
                n_assert(shdNode->materialType->HashCode() < 4096); // maximum of 4095 materials supported (0xFFF0000000000000 bits when converted to weight)
                int64 materialWeight = (uint64)shdNode->materialType->HashCode() << 52; // use the most significant 12 bits for storing material weight

                // note: this assumes the same thing as above but for model nodes
                n_assert(inst->node->HashCode() < 1048757); // maximum of 1048757 model nodes supported (0x000FFFFF00000000 bits when converted to weight)
                int64 nodeWeight = (uint64)inst->node->HashCode() << 32;
                
                indexBuffer[i] = materialWeight | nodeWeight | indexBuffer[i]; // bottom 32 bits is the atom index
            }
            i++;
        }

        // sort the index buffer
        indexBuffer.SortWithFunc([](uint64 const& lhs, uint64 const& rhs)
        {
            // sort in descending order
            return lhs < rhs;
        });

        // Now resolve the indexbuffer into draw commands
        Materials::MaterialType* currentMaterial = nullptr;
        Models::ModelNode* currentModelNode = nullptr;
        uint32 numDraws = 0;
        for (uint32 i = 0; i < indexBuffer.Size(); i++)
        {
            Models::ModelNode::Instance* const inst = nodes[indexBuffer[i] & 0x00000000FFFFFFFF];
            Models::ShaderStateNode::Instance* const shdNodeInst = reinterpret_cast<Models::ShaderStateNode::Instance*>(inst);
            Models::ShaderStateNode* const shdNode = reinterpret_cast<Models::ShaderStateNode*>(inst->node);
            if (numDraws > 0 && (currentMaterial != shdNode->materialType || currentModelNode != inst->node))
            {
                ObserverContext::VisibilityDrawCommand cmd;
                cmd.type = ObserverContext::VisibilityDrawCommand::Type::Draw;
                cmd.draw.numDrawPackets = numDraws;
                cmd.draw.packetOffset = drawList->drawPackets.Size() - numDraws;
                drawList->commandBuffer.Append(cmd);
                numDraws = 0;
            }

            if (currentMaterial != shdNode->materialType)
            {
                currentMaterial = shdNode->materialType;
                ObserverContext::VisibilityDrawCommand cmd;
                cmd.type = ObserverContext::VisibilityDrawCommand::Type::Begin_Material;
                cmd.material = currentMaterial;
                drawList->materialOffsets.Add(currentMaterial, drawList->commandBuffer.Size());
                drawList->commandBuffer.Append(cmd);
            }

            if (currentModelNode != inst->node)
            {
                currentModelNode = inst->node;
                ObserverContext::VisibilityDrawCommand cmd;
                cmd.type = ObserverContext::VisibilityDrawCommand::Type::Begin_Node;
                cmd.node = currentModelNode;
                drawList->commandBuffer.Append(cmd);
            }
            
            // allocate memory for draw packet
            void* mem = packetAllocator->Alloc(shdNodeInst->GetDrawPacketSize());
            // update packet and add to list
            Models::ModelNode::DrawPacket* packet = shdNodeInst->UpdateDrawPacket(mem);
            drawList->drawPackets.Append(packet);
            numDraws++;
        }
        if (numDraws > 0) // add the last draw packets
        {
            ObserverContext::VisibilityDrawCommand cmd;
            cmd.type = ObserverContext::VisibilityDrawCommand::Type::Draw;
            cmd.draw.numDrawPackets = numDraws;
            cmd.draw.packetOffset = drawList->drawPackets.Size() - numDraws;
            drawList->commandBuffer.Append(cmd);
        }
    }
}

} // namespace Visibility
