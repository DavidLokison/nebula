//------------------------------------------------------------------------------
//  visibilitysortjob.cc
//  (C) 2018-2020 Individual contributors, see AUTHORS file
//------------------------------------------------------------------------------
#include "render/stdneb.h"
#include "jobs/jobs.h"
#include "visibilitycontext.h"
#include "models/modelcontext.h"
#include "models/nodes/shaderstatenode.h"
#include "profiling/profiling.h"
#include "timing/timer.h"
namespace Visibility
{

//------------------------------------------------------------------------------
/**
*/
void
VisibilitySortJob(const Jobs::JobFuncContext& ctx)
{
    N_SCOPE(VisibilitySortJob, Visibility);
    Memory::ArenaAllocator<1024>* packetAllocator = (Memory::ArenaAllocator<1024>*)ctx.uniforms[0];
    packetAllocator->Release();

    for (ptrdiff sliceIdx = 0; sliceIdx < ctx.numSlices; sliceIdx++)
    { 
        Math::ClipStatus::Type* results = (Math::ClipStatus::Type*)N_JOB_INPUT(ctx, sliceIdx, 0);
        Models::ModelNode::Instance** const nodes = (Models::ModelNode::Instance**)N_JOB_INPUT(ctx, sliceIdx, 1);
        ObserverContext::VisibilityDrawList* drawList = (ObserverContext::VisibilityDrawList*)N_JOB_OUTPUT(ctx, sliceIdx, 0);

        // calculate amount of models
        uint32 numNodeInstances = ctx.inputSizes[0] / sizeof(Math::ClipStatus::Type);

        if (numNodeInstances == 0)
            break;

        n_assert(numNodeInstances < 0xFFFFFFFF)
        
        Util::Array<uint64> indexBuffer;
        for (uint32 i = 0; i < numNodeInstances; i++)
            indexBuffer.Append(i);

        // loop over each node and give them the appropriate weight
        uint32 i = 0;
        while (i < indexBuffer.Size())
        {
            n_assert(indexBuffer[i] < 0x00000000FFFFFFFF);
            uint64 index = indexBuffer[i] & 0x00000000FFFFFFFF;
            Models::ModelNode::Instance* const inst = nodes[index];
            Models::NodeBits bits = inst->node->GetBits();

            // only treat renderable nodes
            if ((bits & Models::HasStateBit) == Models::HasStateBit)
            {
                if (results[index] == Math::ClipStatus::Outside)
                {
                    indexBuffer.EraseIndexSwap(i);
                    continue;
                }

                Models::ShaderStateNode::Instance* const shdNodeInst = reinterpret_cast<Models::ShaderStateNode::Instance*>(inst);
                if (!shdNodeInst->active)
                {
                    indexBuffer.EraseIndexSwap(i);
                    continue;
                }

                Models::ShaderStateNode* const shdNode = reinterpret_cast<Models::ShaderStateNode*>(inst->node);
                n_assert(bits == shdNode->GetBits());

                // note: this assumes the materialType HashCode returns a unique id for each materialType that is generated by counting up from 0.
                //       if we hit this asserts, we might have too many materials or we've changed the way that we assign unique ids to the different materials.
                //       this means we need to rewrite how we sort the indexbuffer, maybe by just storing 3 values, and sorting based on that.
                n_assert(shdNode->materialType->HashCode() < 4096); // maximum of 4095 materials supported (0xFFF0000000000000 bits when converted to weight)
                int64 materialWeight = (uint64)shdNode->materialType->HashCode() << 52; // use the most significant 12 bits for storing material weight

                // note: this assumes the same thing as above but for model nodes
                n_assert(inst->node->HashCode() < 1048757); // maximum of 1048757 model nodes supported (0x000FFFFF00000000 bits when converted to weight)
                int64 nodeWeight = (uint64)inst->node->HashCode() << 32;
                
                indexBuffer[i] = materialWeight | nodeWeight | indexBuffer[i]; // bottom 32 bits is the atom index
            }
            i++;
        }

        if (indexBuffer.IsEmpty())
            return; // early out

        // sort the index buffer
        std::qsort(indexBuffer.Begin(), indexBuffer.Size(), sizeof(uint64), [](const void* a, const void* b)
        {
            uint64 arg1 = *static_cast<const uint64*>(a);
            uint64 arg2 = *static_cast<const uint64*>(b);
            return (arg1 > arg2) - (arg1 < arg2);
        });
       
        // Now resolve the indexbuffer into draw commands
        uint32 numDraws = 0;
        const uint32 numPackets = indexBuffer.Size();
        drawList->drawPackets.Reserve(numPackets);
        
        Materials::MaterialType* currentMaterialType = nullptr;
        {
            // set initial material type
            auto* const inst = nodes[indexBuffer[0] & 0x00000000FFFFFFFF];
            auto* const shdNode = reinterpret_cast<Models::ShaderStateNode*>(inst->node);
            currentMaterialType = shdNode->materialType;
        }

        for (uint32 i = 0; i < numPackets; i++)
        {
            Models::ModelNode::Instance* const inst = nodes[indexBuffer[i] & 0x00000000FFFFFFFF];
            Models::ShaderStateNode::Instance* const shdNodeInst = reinterpret_cast<Models::ShaderStateNode::Instance*>(inst);
            Models::ShaderStateNode* const shdNode = reinterpret_cast<Models::ShaderStateNode*>(inst->node);

            if (currentMaterialType != shdNode->materialType)
            {
                ObserverContext::VisibilityDrawCommand cmd;
                cmd.packetOffset = drawList->drawPackets.Size() - numDraws;
                cmd.numDrawPackets = numDraws;
                drawList->visibilityTable.Add(currentMaterialType, cmd);
                currentMaterialType = shdNode->materialType;
                numDraws = 0;
            }

            // allocate memory for draw packet
            void* mem = packetAllocator->Alloc(shdNodeInst->GetDrawPacketSize());
            // update packet and add to list
            Models::ModelNode::DrawPacket* packet = shdNodeInst->UpdateDrawPacket(mem);
            drawList->drawPackets.Append(packet);
            numDraws++;
        }

        // make sure to not miss the last couple of draw packets material
        if (numDraws) 
        {
            ObserverContext::VisibilityDrawCommand cmd;
            cmd.packetOffset = drawList->drawPackets.Size() - numDraws;
            cmd.numDrawPackets = numDraws;
            drawList->visibilityTable.Add(currentMaterialType, cmd);
        }
    }
}

} // namespace Visibility
